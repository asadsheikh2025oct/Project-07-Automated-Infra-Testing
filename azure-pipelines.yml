trigger:
  branches:
    include:
      - main

pool:
  vmImage: 'ubuntu-latest'

variables:
  resourceGroupName: 'rg-automation-infra-testing'
  location: 'ukwest'
  # subscriptionId is pulled from the Pipeline UI Variables (Secret)

stages:
- stage: Deploy
  jobs:
  - job: Provision
    steps:
    - task: AzureResourceManagerTemplateDeployment@3
      name: DeployVM
      inputs:
        deploymentScope: 'Resource Group'
        azureResourceManagerConnection: 'Azure-Service-Connection' 
        subscriptionId: '$(subscriptionId)'
        action: 'Create Or Update Resource Group'
        resourceGroupName: '$(resourceGroupName)'
        location: '$(location)'
        templateLocation: 'Linked artifact'
        csmFile: 'main.bicep'
        overrideParameters: '-adminPassword "P@ssword1234!"' 
        deploymentOutputs: 'deploymentOutputs'

    - bash: |
        # Parse the JSON output from the Bicep deployment
        echo "Raw deployment outputs:"
        echo '$(deploymentOutputs)'
        
        # Extract the IP address using jq (pre-installed on Ubuntu agents)
        VM_IP=$(echo '$(deploymentOutputs)' | jq -r '.vmIpAddress.value')
        
        echo "The VM IP captured is: $VM_IP"
        
        # Set the output variable for the next stage
        echo "##vso[task.setvariable variable=VM_IP;isOutput=true]$VM_IP"
      name: CaptureVMIP
      displayName: 'Capture VM IP Address'

- stage: Test
  dependsOn: Deploy
  condition: succeeded()
  jobs:
  - job: RunConnectivityTests
    variables:
      VM_IP: $[ stageDependencies.Deploy.Provision.outputs['CaptureVMIP.VM_IP'] ]
    steps:
    - bash: |
        echo "VM_IP variable value: $(VM_IP)"
        
        # Make the test script executable
        chmod +x test_vm_reachability.py
        
        # Run the Python test script
        python3 test_vm_reachability.py
      displayName: 'Run VM Reachability Tests'
      env:
        VM_IP: $(VM_IP)

    # Optional: If you want to convert results to a test format Azure DevOps understands
    # This step creates a simple JUnit XML file for test reporting
    - bash: |
        # Create a simple test results directory
        mkdir -p test-results
        
        # Run tests and capture exit code
        python3 test_vm_reachability.py > test-results/output.log 2>&1
        TEST_EXIT_CODE=$?
        
        # Create JUnit XML format report
        cat > test-results/results.xml << 'EOF'
        <?xml version="1.0" encoding="UTF-8"?>
        <testsuites>
          <testsuite name="VM Reachability Tests" tests="2" failures="0" errors="0" skipped="0">
            <testcase name="VM IP Variable Test" classname="VMReachabilityTests" />
            <testcase name="SSH Port Connectivity Test" classname="VMReachabilityTests" />
          </testsuite>
        </testsuites>
        EOF
        
        # If tests failed, update the XML
        if [ $TEST_EXIT_CODE -ne 0 ]; then
          cat > test-results/results.xml << 'EOF'
        <?xml version="1.0" encoding="UTF-8"?>
        <testsuites>
          <testsuite name="VM Reachability Tests" tests="2" failures="1" errors="0" skipped="0">
            <testcase name="VM IP Variable Test" classname="VMReachabilityTests" />
            <testcase name="SSH Port Connectivity Test" classname="VMReachabilityTests">
              <failure message="Test failed - see logs for details" />
            </testcase>
          </testsuite>
        </testsuites>
        EOF
        fi
        
        exit $TEST_EXIT_CODE
      displayName: 'Run Tests with JUnit Output'
      env:
        VM_IP: $(VM_IP)
      condition: succeededOrFailed()

    - task: PublishTestResults@2
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: 'test-results/results.xml'
        failTaskOnFailedTests: true
        testRunTitle: 'VM Reachability Tests'
      displayName: 'Publish Test Results'
      condition: always()
